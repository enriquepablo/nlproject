= nl

== Introduction

nl is a python API that aims to take the natural language as its model. The idea is to use it to build rules and sentences, and to do it in a manner as close as possible to the way they are built in the natural languages. The final goal of nl would be to be able to describe or explain with it anything that can be explained or described in one's own mother tongue, and to obtain, in both cases, //texts// of similar complexity.

The aim of nl is not to propose any ontology, but a system to build ontologies; and a system, also, capable of obtaining, given an ontology and the description of a state of affairs using that ontology (which we might call "a text"), all the logical consecuences of (or the contradictions in) that text. nl relies internally on the [[http://clipsrules.sourceforge.net/|clips]] expert system for this.

There are many structures in the natural languages that cannot be expressed in nl in its present state. Conjunction is only implemented at the level of sentences, so there cannot be lists of things; negation is not clearly defined; modal logic is not implemented; and much more. I believe, however, that they can  be added without violence, and there is a short discussion on these issues at the end of this document.

== Usage

The API consists of a few classes, basically {{{ Thing }}}, {{{ State }}}, {{{ Number }}}, {{{ Fact }}}, and {{{ Rule }}}, and a few functions, basically, {{{ tell }}}, {{{ extend }}} and {{{ ask }}}. These classes are used to build sentences, as instances of them. Afterwards, the function {{{ extend }}} is used to obtain all logical consecuences of a set of sentences, and {{{ ask }}} is used to query the system.

=== Thing

{{{Thing }}} is subclassed to make what will be used like common nouns, e.g., "man". The derived classes are instantiated with a string representing a proper noun. This strings have to be legal python names.

{{{
#!python

>>> from nl import Thing, State, Number, Prop, Rule, kb

>>> class Man(Thing):
...     pass

>>> john = Man('john')

>>> kb.open()
>>> kb.tell(john)
}}}

These instances can be used in two ways. They can be passed directly to {{{ tell }}}, and that will be like asserting an attributive sentence, "John is a man". Once they have been added to the system with {{{ tell }}}, they can be used in propositions, as subject or object; more on this later.

If you instantiate again {{{ Man }}} with {{{ 'john' }}}, you get another python instance, that, however, corresponds to the same underlying clips instance. This means that, logically, both instances are the same.

=== State

{{{ State }}} is subclassed to make what will be used as verbs. Its derived classes are defined with a dictionary {{{ mods }}} of strings to classes, which have to be subclasses of {{{ Thing }}}, {{{ State }}}, or {{{ Number }}} (also from the nl namespace). This {{{ mods }}} dict represents the possible modificators that the verb can have when used in a proposition. The subclasses of State can also take an attribute named {{{ subject }}} of classx {{{ Thing }}}.

{{{
#!python

>>> class Food(Thing): pass

>>> class Eats(State):
...     subject = Man
...     mods = {'edible': Food,
...             'grams': Number}
}}}

When instantiating a verb, it is not necessary to provide all the names defined within {{{ mods }}}, and you can also provide names defined in a superclass' {{{ mods }}}.

Classes derived from {{{ State }}} are only instantiated as predicates within propositions, and are given, as {{{ **kwargs }}}, a dictionary equivalent to the {{{ mods }}} of the class, but with instances instead of classes: {{{ Eats( edible = Food('banana'), grams = 300) }}}.

One natural language verb that should not be represented in nl as subclass of {{{ State }}} is "to be". "To be" is given by the set theory implicit in the class system, as was seen when we built the "john is a man" sentence.

=== Fact

{{{ Fact }}} is instantiated to make propositions, with three positional args representing subject, predicate, and time. As subject, it requires a thing instance, as predicate a state instance, and as time, a number.

{{{
#!python

>>> p1 = Proposition( john, Eats( edible = Food('banana'), grams = 300), 0 )

>>> kb.tell(p1)
}}}

=== Rule

{{{ Rule }}} is instantiated to build rules. The constuctor takes three positional arguments: a name string, and 2 lists of propositions and things, to act as premises and as consecuences. What clips will do with all this is to seek for instances that match the premises, and once it covers all of them, adds the consecuences as stand-alone sentences.

Variables can be used within rules. They are given by a string composed by an upper case letter followed by digits. They can be used in the place of the subject, the predicate, any of its mods, or the time. Their scope is the rule where they appear, and their only role is to match, when present in the premises, and to be substituted by the match when present in the consecuences.

{{{
#!python

>>> r1 = Rule('r1',
...           [Proposition( Man('M1'),
...                         Eats( edible = Food('banana'), grams = 'X1'),
...                         'T1' )],
...           [Proposition( Man('M1',
...                         Eats( edible = Food('pie'), grams = '(+ X1 2)'),
...                         'T1')])


>>> kb.tell(r1)
}}}

This rule would mean (absurdly) that whenever a man eats bananas, he also eats 2 grams more of pie, as can be seen in the next section.

=== extend and ask

Now, we can extend the database to all its logical consecuences. With the previous sentences, there is only one consecuence: that john eats 302 grs of pie:

{{{
#!python

>>> kb.extend()

>>> kb.ask(Proposition( john, Eats( edible = Food('pie'), grams = 302), 0 ))
john Eats ['edible=pie', 'grams=302'] at 0

>>> kb.ask(Proposition( john, Eats( edible = Food('apple'), grams = 302), 0 ))
'no'

>>> kb.ask(Proposition( john, Eats( edible = Food('X1'), grams = 'X2'), 0 ))
john Eats ['edible=pie', 'grams=302'] at 0, john Eats ['edible=banana', 'grams=300'] at 0

}}}

This won't actually work if typed in a python interactive interpreter; the classes have to be declared in the filesystem for nl to work. So, we should take the definitions of {{{ Man }}}, {{{ Food }}}, and {{{ Eats }}} to a python module, and import it from the interactive interpeter, for this example to work.

finally, we must not forget to close the database.
{{{
#!python

>>> kb.close()
}}}

=== Arithmetics

Modificators in predicates can have a numeric value, specified in the verb definition as {{{ Number }}}. In stand alone propositions, numbers are just numbers, integers or floats. In a rule, they can be arithmetic operations in which variables take part. The syntax for this operations is consecuence of working with clips at the time of diciding it: {{{ (<op> <arg1> <arg2>) }}}. At the moment, only binary operations are allowed. Of course, any of the arguments can itself be an operation. The operators can be any of the arithmetic operators allowed in python.

Additionally, we can include arithmetic sentences, with truth value instead of numeric value, as premises in a rule. The allowed predicates are the arithmetic predicates allowed in python, and the syntax is the same as that of operations.


== Design decissions to take

1.- Time. I have chosen to add a time component to propositions. Time could ovbiously be an optional modificator of verbs in predicates. But in //my// natural language it is always present, if only as verb conjugation.

2.- No adjectives. This relates to the previous discussion about time. The different treatment of "to be" and the other verbs means that to be is timeless in this framework. Adjetives would also be timeless.

3.- No Verbs/preds as mods in preds. to implement.

4.- No negation. give it as an alternative. Closed world scenario (the present), were absence implies negation, and closed world, where there is proper negation and the unknown.

5.- modal logic. Has no sense in the closed world scenario. and limited to the types of questions (ask) available in an open world scenario. This is, adding modal logic means adding a way of asking whether something is possible (is unknown; is in the consecuences of some almost covered rule; etc.) adding probability algebra can be done directly with normal propositions.

6.- zodb. I have added zodb persistence. clips, as far as I can see, only allows me to load or save the whole file. With zodb i can atomically save sentences. And I already had objects that fitted in the zodb like in a glove. In any case the state of the system is maintained in clips, so it is not critical. 


== from the perspective of the semantic web

The semantic web provides OWL, that is somewhat comparable to nl. Of course OWL and nl are quite different things. OWL is a markup language, with no logic, designed to speak about web resources, and to be understood by external inference engines. nl s a python API. However, they share a common characteristic. They both try to be machine languages modelled on the natural language.


A key difference between OWL and nl is that nl is both a language and an inference machine, whereas OWL is just a language that can be processed by different inference machines. This means that OWL is much more verbose, as it has to make explicit many aspects that in nl can be implicit due to the close relation between language and inference machine. Following this, it could be thouhgt that nl might be used to make an inference machine for OWL. The basic formal structure is different, however. And it is this difference that this comparison is about.

It could be said that the semantic web has gone the way of set theory. At first, Frege and Russell thought that (naïve) set theory was a "machine language" modelled on the natural language. Later, Russell discovered that one of the pillars of their edifice was planted on the mud of contradiction. Their edifice was essentially the same as that of the semantic web: classes of individuals, and predicates over those individuals with truth value, and first order logic's rules of inference.

The pillar that was faulty was the axiom of unrestricted comprehension. This stated that every predicate has a corresponding class of individuals, those that make it true with it. And, what it effectively provided, was the ability of cuantifying over predicates. FOL doesn't allow that, but the natural languages allow it, so you can say: "whatever he does, he does it right". Unrestricted comprehension gave, for every predicate, a class, an individual in the universe of discourse, cuantifyable over; and it is the same to say "I am here now" than "I belong to the class of things that are here now". 

Since they lost their axiom of UC, they stopped thinking that their system was modelled in the NL. They tried to circumvent that problem but did not succeed.

The semantic web is in much the same position with regards to inference engines using it. When searching full expresiveness, in OWL Full, it allows classes to be treated as individuals. And classes cannot be treated as individuals because they correspond to predicates. You can even have an "unnamed class that represents the set of things with at least one madeFromGrape property" ([http://www.w3.org/TR/2003/PR-owl-guide-20031215#DefiningProperties w3c]). So this leads directly to contradiction.

That is not something that the semantic web proponents try to hide. However, the only sound OWL system OWL DL, has no cuantification over predicates. And with very litle semantic addition to any ontology you can obtain an explosion of complexity. "whatever he does, he does it right" would have to become: "if he plays football with a few friends in such and such yard blah blah blah, he plays well"; etc.

The language proposed here rests upon a FOL foundation that I think solves the problem outlined above. It basically takes the same initial road, up to defining the basic set-theoretic predicates and making them correspond with the natural verb "to be". The rest of the natural verbs, however, are introduced as operators, with the trick that a proposition made with an operator, corresponding in NL to a proposition with truth value, is an individual that belongs (or not) to the set of "facts", and this "belongs" is now a predicate of the language, with truth value. This way, predicates are actually individuals in the universe of discourse, and so, can be cuantifyed over.

----

Enrique Pérez Arnaud © 2008 
